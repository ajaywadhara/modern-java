# Java 8-11 Features

## Lambda Expressions (Java 8)

```java
// BEFORE: Anonymous inner class
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        handleClick();
    }
});

// AFTER: Lambda
button.addActionListener(e -> handleClick());
```

**Common functional interfaces:**
```java
Predicate<String> p = s -> s.isEmpty();
Consumer<String> c = s -> System.out.println(s);
Function<A, B> f = a -> transform(a);
Supplier<T> s = () -> create();
BiFunction<A, B, C> bf = (a, b) -> combine(a, b);
```

---

## Stream API (Java 8)

### Filter + Map + Collect
```java
// BEFORE
List<String> names = new ArrayList<>();
for (Person p : people) {
    if (p.getAge() > 18) {
        names.add(p.getName().toUpperCase());
    }
}

// AFTER
List<String> names = people.stream()
    .filter(p -> p.getAge() > 18)
    .map(p -> p.getName().toUpperCase())
    .toList();
```

### Find First / Any Match
```java
// BEFORE
for (Person p : people) {
    if (p.getName().equals("John")) {
        return p;
    }
}

// AFTER
people.stream()
    .filter(p -> p.getName().equals("John"))
    .findFirst();
```

### Grouping
```java
// Map<String, List<Person>>
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// Partitioning
Map<Boolean, List<Integer>> evenOdd = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
```

---

## Optional (Java 8)

### Null Chain
```java
// BEFORE
String city = "Unknown";
if (person != null) {
    Address addr = person.getAddress();
    if (addr != null) {
        city = addr.getCity();
    }
}

// AFTER
String city = Optional.ofNullable(person)
    .map(Person::getAddress)
    .map(Address::getCity)
    .orElse("Unknown");
```

### Optional Patterns (Java 9+)
```java
// ifPresentOrElse
opt.ifPresentOrElse(
    value -> process(value),
    () -> handleMissing()
);

// or - alternative Optional
opt.or(() -> Optional.of(fallback));

// stream
opt.stream().filter(x -> x > 0).findFirst();
```

---

## CompletableFuture (Java 8)

```java
// Async chain
CompletableFuture.supplyAsync(this::fetchData)
    .thenApply(this::process)
    .thenAccept(this::save)
    .exceptionally(ex -> handleError(ex));

// Combine futures
CompletableFuture<String> combined = future1.thenCombine(future2, (r1, r2) -> r1 + r2);
```

---

## Collection Factories (Java 9+)

```java
// Immutable lists
List<String> list = List.of("a", "b", "c");
Set<Integer> set = Set.of(1, 2, 3);

// Immutable maps
Map<String, Integer> map = Map.of("a", 1, "b", 2);
Map<String, Integer> bigMap = Map.ofEntries(
    Map.entry("a", 1),
    Map.entry("b", 2)
);
```

---

## var Keyword (Java 10)

```java
// Type inference for local variables
var names = new ArrayList<String>();
var result = complexMethod();
for (var entry : map.entrySet()) {
    // var works with for-each
}
```

---

## HttpClient (Java 11)

```java
// BEFORE: HttpURLConnection
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("GET");
int code = conn.getResponseCode();

// AFTER: HttpClient
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create(url))
    .GET()
    .build();
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
```

---

## String Methods (Java 11+)

```java
"  hello  ".isBlank();     // true
"hello".lines();           // Stream of lines
"  hello  ".strip();       // "hello" (Unicode aware)
"abc".repeat(3);          // "abcabcabc"
```

---

## toList() (Java 16+)

```java
// BEFORE
list.stream().map(...).collect(Collectors.toList());

// AFTER
list.stream().map(...).toList();
```

---

## Version Detection

When detecting Java version, these features are available:

| Version | Features |
|---------|----------|
| 8 | Lambdas, Streams, Optional, CompletableFuture |
| 9 | Collection factories, Private interface methods |
| 10 | var keyword |
| 11 | String methods, HttpClient |
