# Java 22-25 Features

## Unnamed Variables & Patterns (Java 22+)

```java
// BEFORE: Unused variable warnings
for (String ignored : list) {
    process();
}

// AFTER: Unnamed variable
for (var _ : list) {
    process();
}

// In catch blocks
try {
    // risky operation
} catch (Exception _) {
    log.error("Failed");
}

// In lambdas
BiFunction<Integer, String, String> f = (i, _) -> "Result: " + i;

// In record patterns
record Point(int x, int y) {}
if (point instanceof Point(int x, var _)) {
    // Use x, ignore y
}
```

---

## Flexible Constructor Bodies (Java 25)

```java
// BEFORE: Must validate inside super() call
public class Child extends Parent {
    public Child(String name) {
        super(validate(name)); // validation mixed with super
    }
}

// AFTER: Statements before super()
public class Child extends Parent {
    public Child(String name) {
        if (name == null) throw new IllegalArgumentException();
        super(name); // Now can validate first
    }
    
    public Child() {
        System.out.println("Creating");
        this("default"); // this() also allowed later
    }
}
```

---

## Compact Source Files (Java 25)

```java
// BEFORE: Required class wrapper
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello!");
    }
}

// AFTER: Simple main method
void main() {
    System.out.println("Hello!");
}

// With parameters
void main(String[] args) {
    System.out.println("Hello, " + args[0]);
}
```

---

## Stream Gatherers (Java 24+)

```java
// windowFixed - fixed-size windows
Stream.of(1, 2, 3, 4, 5, 6, 7)
    .gather(Gatherers.windowFixed(3))
    .toList();  // [[1,2,3], [4,5,6], [7]]

// windowSliding - sliding window
Stream.of(1, 2, 3, 4, 5)
    .gather(Gatherers.windowSliding(3))
    .toList();  // [[1,2,3], [2,3,4], [3,4,5]]

// fold - running total
Stream.of(1, 2, 3, 4, 5)
    .gather(Gatherers.fold(() -> 0, Integer::sum))
    .toList();  // [1, 3, 6, 10, 15]

// mapConcurrent - concurrent transformation
Stream.of("a", "b", "c")
    .gather(Gatherers.mapConcurrent(10, this::processAsync))
    .toList();
```

---

## Scoped Values (Java 25 Final)

```java
// Final version - fully production ready
private static final ScopedValue<User> CURRENT_USER = ScopedValue.create();

void handleRequest(Request req, User user) {
    ScopedValue.where(CURRENT_USER, user)
        .run(() -> processRequest());
}

void processRequest() {
    User u = CURRENT_USER.get();
    // Available in all nested calls
}

// Rebinding in nested scopes
void adminOperation() {
    ScopedValue.where(CURRENT_USER, adminUser)
        .run(() -> {
            // CURRENT_USER = adminUser
            ScopedValue.where(CURRENT_USER, regularUser)
                .run(() -> {
                    // CURRENT_USER = regularUser
                });
            // CURRENT_USER = adminUser again
        });
}
```

---

## Primitive Patterns (Java 23+ Preview)

```java
// BEFORE: Only reference types
if (obj instanceof Integer i) { ... }

// AFTER: Primitive types in patterns
switch (value) {
    case int i when i < 0 -> "negative: " + i;
    case int i -> "positive: " + i;
    case long l -> "long: " + l;
    case double d -> "double: " + d;
}

// In instanceof
if (obj instanceof int i && i > 0) {
    System.out.println("Positive int: " + i);
}
```

---

## Module Import Declarations (Java 25)

```java
// BEFORE: Many individual imports
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.ArrayList;
import java.util.HashMap;

// AFTER: Import entire module
import module java.util;

// All exported classes from java.util now available
List<String> list = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();
```

---

## Stable Values (Java 25 Preview)

```java
// Lazily computed, cached values
StableValue<String> cached = StableValue.of();

String value = cached.orElseSet(() -> expensiveComputation());
// Computed once, then cached

// For arrays
StableValue<String>[] cache = StableValue.ofArray(10);
cache[0].orElseSet(() -> compute());
```

---

## Foreign Function & Memory API (Java 22+)

```java
// Call native functions
Linker linker = Linker.nativeLinker();
MethodHandle strlen = linker.downcallHandle(
    linker.defaultLookup().find("strlen").get(),
    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)
);

try (Arena arena = Arena.ofConfined()) {
    MemorySegment str = arena.allocateFrom("Hello");
    long len = (long) strlen.invokeExact(str);  // 5
}
```

---

## Key Derivation Function API (Java 25)

```java
// PBKDF2
Kdf kdf = Kdf.getInstance("PBKDF2");
SecretKey key = kdf.derive(password, salt,
    KdfParameters.pbkdf2(HashFunction.SHA256, 310000, 256));

// HKDF
Kdf hkdf = Kdf.getInstance("HKDF-SHA256");
SecretKey derived = hkdf.derive(inputKey, salt,
    KdfParameters.hkdf(HashFunction.SHA256, info, 32));
```

---

## Pattern Detection

| Legacy Pattern | Detection | Modern Alternative |
|---------------|-----------|-------------------|
| for with unused var | `for\s*\(\s*\w+\s+\w+\s*:\s*\)` | Unnamed variable `_` |
| Constructor validation | N/A | Flexible constructors |
| Main method class | `public\s+class.*\{` | Compact source file |
| Collect to list | `.collect\(Collectors` | Stream gatherers |

---

## Version Features

| Version | Features |
|---------|----------|
| 22 | Unnamed variables (final), Flexible constructors (preview), Stream gatherers (preview), FFM API (final) |
| 23 | Primitive patterns (preview), Module imports (preview), Markdown docs |
| 24 | Stream gatherers (final), Synchronize without pinning, KDF API (preview) |
| 25 | Scoped values (final), Flexible constructors (final), Compact source files (final), Module imports (final), KDF API (final) |
